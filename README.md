# JS-Questions-Exercises
JS Questions &amp; Exercises

## Вопросы

1. What will the code below output to the console and why?
```javascript
(function(){
  var a = b = 3;
})();

console.log("a defined? " + (typeof a !== 'undefined'));
console.log("b defined? " + (typeof b !== 'undefined'));
```
2. Необходимо, чтобы этот код выводил в лог hey amy, но он выводит hey arnold. Почему?
```javascript
function greet(person) {
  if (person == { name: 'amy' }) {
    return 'hey amy'
  } else {
    return 'hey arnold'
  }
}
greet({ name: 'amy' })
```
## Задания
2. Реализуйте функцию isPrime(), которая возвращает true или false, указывая, является ли переданное ей число простым.
```javascript
const isPrime = (number) => {
    if (number < 2) {
        return false;
    }

    for (let i = 2; i < number; i += 1) {
        if (number % i === 0) {
        return false;
        }
    }

    return true;
};
```
3. Реализуйте функцию factorial(), которая возвращает факториал переданного ей числа.
```javascript
const factorial = num => {
    if (num <= 1) {
        return 1;
    }

    const iter = (count, acc) => {
        if (count === 1) {
            return acc;
        }

        return iter(count - 1, count * acc);
    };

    return iter(num, 1);
};
```
4. Реализуйте функцию fib(), возвращающую n-ное число Фибоначчи.
```javascript
const fib = n => n <= 1 ? n : fib(n - 1) + fib(n - 2);};
```
1. Реализуйте функцию isSorted(), которая возвращает true или false в зависимости о того, отсортирован ли переданный ей числовой массив.
1. Создайте собственную реализацию функции filter().
1. Создайте собственную реализацию функции reduce().
1. Реализуйте функцию reverse(), которая обращает порядок следования символов переданной ей строки. Не пользуйтесь встроенной функцией reverse().
1. Создайте собственную реализацию функции indexOf() для массивов.
1. Реализуйте функцию isPalindrome(), которая возвращает true или false в зависимости от того, является ли переданная ей строка палиндромом (функция нечувствительна к регистру и к наличию в строке пробелов).
1. Реализуйте функцию missing(), которая принимает неотсортированный массив уникальных чисел (то есть, числа в нём не повторяются) от 1 до некоего числа n, и возвращает число, отсутствующее в последовательности. Там может быть либо одно отсутствующее число, либо их может не быть вовсе.
1. Способны ли вы добиться того, чтобы функция решала задачу за время O(N)? Подсказка: есть одна хорошая формула, которой вы можете воспользоваться.
1. Реализуйте функцию isBalanced() которая принимает строку и возвращает true или false, указывая на то, сбалансированы ли фигурные скобки, находящиеся в строке.
1. Реализуйте функцию fib2(). Она похожа на функцию fib() из предыдущей группы заданий, но поддерживает числа вплоть до 50. Подсказка: используйте мемоизацию.
1. Реализуйте функцию isBalanced2(). Она похожа на функцию isBalanced() из предыдущей группы заданий, но поддерживает три типа скобок: фигурные {}, квадратные [], и круглые (). При передаче функции строки, в которой имеются неправильные скобочные последовательности, функция должна возвращать false.
1. Реализуйте функцию uniq(), которая принимает массив чисел и возвращает уникальные числа, найденные в нём. Может ли функция решить эту задачу за время O(N)?

1. Реализуйте функцию intersection(), которая принимает два массива и возвращает их пересечение. Можете ли вы добиться того, чтобы функция решала эту задачу за время O(M+N), где M и N — длины массивов?
1. Создайте реализацию функции sort(), которая сортирует числовой массив за время O(N×log(N)).
1. Реализуйте функцию includes(), которая возвращает true или false в зависимости от того, встречается ли переданное ей число в переданном ей отсортированном массиве. Может ли функция решить эту задачу за время O(log(N))?

1. Реализуйте функцию assignDeep(), которая похожа на Object.assign(), но выполняет глубокое объединение объектов. Для того, чтобы не усложнять задачу, можно исходить из допущения, что объекты могут содержать только числа и другие объекты (в них не может быть массивов, строк, и так далее).
1. Реализуйте функцию reduceAsync(), которая похожа на функцию reduce() из группы простых заданий, но работает с функциями, возвращающими promise-объекты, каждый из которых должен быть разрешён до перехода к следующему.

1. Реализуйте функцию seq(), пользуясь тем же подходом, что и при работе над функцией reduceAsync(). Эта функция должна принимать массив функций, которые возвращают promise-объекты, и разрешать их один за другим.

1. Реализуйте функцию permute(), которая возвращает массив строк, содержащий все пермутации заданной строки.
1. Создайте самостоятельную реализацию функции debounce().
1. Реализуйте класс LinkedList, не используя встроенные массивы JavaScript ( [] ). Ваш LinkedListдолжен поддерживать лишь 2 метода: add() и has().
1. Реализуйте класс HashMap, не используя встроенные объекты JavaScript ( {} ) или функцию map(). Вам дана функция hash(), которая принимает строку и возвращает некое число. Эти числа, в основном, уникальны, но возможна и ситуация, когда двум разным строкам соответствуют одинаковые числа.
1. Ваша реализация HashMap должна поддерживать лишь 2 метода: get() и set().
1. Реализуйте класс BinarySearchTree. Он должен поддерживать 4 метода: add(), has(), remove(), и size().
1. Реализуйте класс BinaryTree, который поддерживает поиск в ширину, а также функции симметричного, прямого и обратного поиска в глубину.
